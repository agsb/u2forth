\ 3.2 COMMONS
:?DUP    DUP IF DUP THEN ;
:ROT     >R SWAP R> SWAP ;
:2DROP   DROP DROP ;
:2DUP    OVER OVER ;
:+       UM+ DROP ;
:NOT     -1 XOR ;
:NEGATE  NOT 1 + ;
:DNEGATE NOT >R NOT 1 UM+ R> + ;
:D+      >R SWAP >R UM+ R> R> + + ;
:-       NEGATE + ;
:ABS     DUP 0< IF NEGATE THEN ;
\ 3.3 COMPARATION
:=       XOR IT - EXIT THEN -1 ;
:U<      2DUP XOR 0< IF SWAP DROP 0< EXIT THEN - 0 ;
:<       2DUP XOR 0< IF DROP 0< EXIT THEN - 0< ;
:MAX     2DUP < IF SWAP THEN DROP ;
:MIN     2DUP SWAP < IF SWAP THEN DROP ;
:WITHIN  OVER - R> - R> U< ;
\ 3.4 DIVIDE
:UM/MOD  2DUP U< IF NEGATE 15 FOR >R DUP UM+ R> R> DUP UM= R> + DUP R> R@ SWAP >R UM+ R> OR IF >R DROP 1 + R> ELSE DROP THEN R> NEXT DROP WSAP EXIT THEN DROP 2DROP -1 DUP ;
:M/MOD   DUP 0< DUP R> IF NEGATE >R DNEGATE R> THEN >R DUP 0< IF R@ + THEN R> UM/MOD R> IF SWAP NEGATE SWAP THEN ;
:/MOD    OVER 0< SWAL M/MOD ;
:MOD     /MOD DROP ;
:/       /MOD SWAP DROP ;
\ 3.5 MULTIPLY
:UM*     0 SWAP 15 FOR DUP UM+ >R >R DUP UM+ R> + R> IF >R OVER UM+ R> THEN NEXT ROT DROP ;
:*       UM* DROP ;
:M*       2DUP XOR 0< >R ABS SWAP ABS UM* R> IF DNEGATE THEN ;
:*/MOD    >R M* R> M/MOD ;
:*/      */MOD SWAP DROP ;
\ 3.6 MEMORY ALIGMENT
:CELL-      -2 + ;
:CELL+      2 + ;
:CELLS      2 * ;
:ALIGNED DUP 0 2 UM/MOD DROP DUP IF 2 SWAP - THEN + ;
:BL      32 ;
:>CHAR   $7F AND DUP 127 BL WITHIN IF DROP 95 THEN ;
:DEPTH   SP@ SP0 @ SWAP - 2 / ;
:PICK    1 + CELLS SP@ + @ ;

\ 3.7 MEMORY ACCESS
:+!      SWAP OVER @ + SWAP ! ;
:2!      SWAP OVER ! CELL+ ! ;
:2@      DUP CELL+ @ SWAP @ ;
:COUNT   DUP 1 + SWAP C@ ;
:HERE    CP @ ;
:PAD     HERE 80 + ;
:TIB     #TIB CELL+ @ ;
:@EXECUTE @ ?DUP IF EXECUTE THEN ;
:CMOVE   FOR AFT >R DUP C@ R@ C! 1 + R> 1 + THEN NEXT 2DROP ;
:FILL    SWAP FOR SWAP AFT 2DUP C! 1 + THEN NEXT 2DROP ;
:-TRAILING FOR AFT BL OVER R@ + C@ < IF R> 1 + EXIT THEN THEN NEXT 0 ;
:PACK$   ALIGNED DUP >R OVER DUP 0 2 UM/MOD DROP - OVER + 0 SWAP ! 2DUP C! 1 + SWAP CMOVE R> ;

\ 4.0 text interpreter

\ 4.1 numeric output
:DIGIT  9 OVER < 7 AND + 48 + ;
:EXTRACT 0 SWAP UM/MOD SWAP DIGIT ;
:<# PAD HLD ! ;
:HOLD   HLD @ 1 - DUP HLD ! C! ;
:#      BASE @ EXTRACT HOLD ;
:#S     BEGIN # DUP WHILE REPEAT ;
:SIGN   0< IF 45 HOLD THEN ;
:#>     DROP HLD @ PAD OVER - ;
:STR    DUP >r ABS <# #S R> SIGN #> ;
:HEX    16 BASE ! ;
:DECIMAL    10 BASE ! ;

\ 4.2 NUMBER OUTPUT
:.R     >R STR R> OVER - SPACES TYPE ;
:U.R    >R <# #S #> R> OVER - SPACES TYPE ;
:U.     <# #S #> SPACE TYPE ;
:.      BASE @ 10 XOR IF U. EXIT THEN STR SPACES TYPE ;
.?      @ . ;

\ 4.3 NUMERIC IMPUT
: DIGIT?    R> 48 - 9 OVER < IF 7 - DUP 10 < OR THEN DUP R> U< ;
: NUMBER?   BASE @ >R 0 OVER COUNT OVER C@ 36 = IF HEX SWAP 1 + SWAP 1 - THEN OVER C@ 36 - IF HEX SWAP 1 + SWAP 1 - THEN OVER C@ 45 = >R SWAP R@ - SWAP R@ + ?DUP IF 1 - FOR DUP >R C@ BASE @ DIGIT?  WHILE SWAP BASE @ * + R> 1 + NEXT DROP R@ IF NEGATE THEN SWAP ELSE R> R> 2DROP 2DROP 0 THEN DUP THEN R> 2DROP R> BASE ! ;

\ 4.4 basic I/O
: ?KEY  '?KEY @EXECUTE ;
: KEY   BEGIN ?KEY UNTIL ;
: EMIT 'EMIT @EXECUTE ;
: NUF?  ?KEY DUO IF 2DROP KEY 13 = THEN ; : PACE  11 EMIT ;
: SPACE 32 EMIT ;
: CHARS SWAP 0 MAX FOR AFT DUP EMIT THEN NEXT DROP ;
: SPACES 32 CHARS ;
: TYPE  FOR AFT DUP C@ EMIT 1 + THEN NEXT DROP ;
: CR    13 EMIT 10 EMIT ;
: DO$   R> R@ R> COUNT + ALIGNED R> SWAP >R ;
: $"|   DO$
: ."|   DO$ COUNT TYPE ; COMPILE-ONLY

\ 4.5 parsing
: PARSE$    TMP ! OVER >R DUP IF 1 - TMP @ BL = IF FOR BL OVER C@ - 0< NOT WHILE 1 + NEXT R> DROP 0 DUP EXIT THEN R> THEN OVER SWAP FOR TMP @ OVER C@ - TMP @ BL = IF 0< THEN WHILE 1 + NEXT DUP R> ELSE R> DROP DUP 1 + >R THEN OVER - R> R> - EXIT THEN OVER R> - ;
: PARSE     >R  TIB >IN @ + #TIB @ >IN @ - R> PARSE$ >IN +! ;
:.(     41 PARSE TYPE ; IMMEDIATE
:(      41 PARSE 2DROP ; IMMEDIATE
:\      #TIB @ >IN ! ; IMMEDIATE
: CHAR  BL PARSE DROP C@ ;
: TOKEN BL PARSE 31 MIN NP @ OVER - CELL- PACK$ ;
: WORD  PARSE HERE PACK$ ;

\4.6 DICTIONARY SEARCH
: NAME> CELL- CELL- @ ;
: SAME? FOR AFT OVER R@ CELLS + @ OVER R@ CELLS + @ - ?DUP IF R> DROP EXIT THEN THEN NEXT 0 ;
: FIND  SWAP DUP C@ 2 / TMP ! DUP @ >R CELL+ SWAP BEGIN @ DUP IF DUP @ [ =MASK ] LITERAL AND R@ XOR IF CELL+ -1 ELSE CELL+ TMP @ SAME? THEN ELSE R> DROP EXIT THE WHILE CELL- CELL- REPEAT R> DROP SWAP DROP CELL- DUP NAME> SWAP ;
: NAME? CONTEXT DUP 2@ XOR IF CELL- THEN >R BEGIN R> CELL+ DUP >R @ ?DUP WHILE FIND ?DUP UNTIL R> DROP EXIT THEN R> DROP 0 ;

\ 4.7 terminal
: ^H    >R OVER R> SWAP OVER XOR IF 8 'ECHO @EXECUTE 32 'ECHO @EXECUTE 8 'ECHO @EXECUTE THEN ;
: TAP   DUP 'ECHO @EXECUTE OVER C! 1 + ;
: KtAP  DUP 13 XOR IF 8 XOR IF BL TAP ELSE ^H THEN EXIT THEN DROP SWAP DROP DUP ;
: ACCEPT    OVER + OVER BEGIN 2DUP XOR WHILE KEY DUP BL - 95 U< IF TAP ELSE 'TAP @EXECUTE THEN
    REPEAT DÂ´ROP OVER - ;
: EXPECT 'EXPECT @EXECUTE SPAN ! DROP ;
: QUERY TIB 80 'EXPECT @EXECUTE #TIB ! DROP 0 >IN ! ;

\ 4.9 text interpreter
: $INTERPRET
    NAME? ?DUP IF @ $40 AND ABORT" _COMPILE_ONLY_ " EXECUTE EXIT
    THEN 'NUMBER @EXECUTE IF EXIT THEN THROW ;
: [ DOLIT $INTERPRET 'EVAL ! ; IMMEDIATE
: .OK DOLIT $INTERPRET 'EVAL @ = IF ." _ok_ " THEN CR ;
: ?STACK DEPTH 0< ABORT" _UNDERFLOW_" ;
: EVAL BEGIN TOKEN DUP C@ WHILE 'EVAL @EXECUTE ?STACK REPEAT DROP 'PROMPT @EXECUTE ;


