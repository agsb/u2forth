\ 998 extended

\ for read and write flash atmega328
: I@ NOOP ;
: I! NOOP ;
: IC@ NOOP ;
: IC! NOOP ;

: DOES R> LAST @ NAME> 2+ I! ;

\ 999 erratas

\CONSTANT CELL 
\VARIABLE UP
\VARIABLE SP0 
\VARIABLE RP0 
\VARIABLE TMP 
\VARIABLE SPAN 
\VARIABLE >IN
\VARIABLE #TIB 
\VARIABLE CSP 
\VARIABLE HLD 
\VARIABLE BASE 
\VARIABLE HANDLER 
\VARIABLE CONTEXT 
\VARIABLE CURRENT
\VARIABLE LAST
\VARIABLE CP 
\VARIABLE NP 
\VARIABLE '?KEY 
\VARIABLE 'EMIT 
\VARIABLE 'EXPECT 
\VARIABLE 'TAP 
\VARIABLE 'ECHO 
\VARIABLE 'PROMPT 
\VARIABLE 'EVAL 
\VARIABLE 'NUMBER 

\ 2.0 eForth kernel primitives
\ BYE ?RX TX! !IO
\ DOLIT DOLIST NEXT ?BRANCH BRANCH EXECUTE EXIT
\ ! @ C! C@
\ RP@ RP! R> R@ >R
\ SP@ SP! DROP DUP SWAP OVER
\ 0< AND OR XOR UM+
\ $NEXT DOLIST EXIT EXECUTE DOLIT
\ NEXT

\ 3.1 high level words
: DOVAR R> ;
: DOUSER R> @ UP # + ;
: DOVOC R> CONTEXT ;
: FORTH DOVOC [ 0 , 0 ;

\ 3.2 common words
: ?DUP DUP IF DUP THEN ;
: ROT >R SWAP R> SWAP ;
: 2DROP DROP DROP ;
: 2DUP OVER OVER ;
: + UM+ DROP ;
: NOT -1 XOR ;
: NEGATE NOT 1 + ;
: DNEGATE NOT >R NOT 1 UM+ R> + ;
: D+ >R SWAP >R UM+ R> R> + + ;
: - NEGATE + ;
: ABS DUP 0< IF NEGATE THEN ;

\ 3.3 comparation
: = XOR IF - EXIT THEN -1 ;
: U< 2DUP XOR 0< IF SWAP DROP 0< EXIT THEN - 0 ;
: < 2DUP XOR 0< IF DROP 0< EXIT THEN - 0< ;
: MAX 2DUP < IF SWAP THEN DROP ;
: MIN 2DUP SWAP < IF SWAP THEN DROP ;
: WITHIN OVER - R> - R> U< ;

\ 3.4 divide
: UM/MOD 2DUP U< IF NEGATE 15 FOR >R DUP UM+ R> R> DUP UM+ R> + DUP R> R@ SWAP >R UM+ R> OR IF >R DROP 1 + R> ELSE DROP THEN R> NEXT DROP SWAP EXIT THEN DROP 2DROP -1 DUP ;
: M/MOD DUP 0< DUP R> IF NEGATE >R DNEGATE R> THEN >R DUP 0< IF R@ + THEN R> UM/MOD R> IF SWAP NEGATE SWAP THEN ;
: /MOD OVER 0< SWAP M/MOD ;
: MOD /MOD DROP ;
: / /MOD SWAP DROP ;

\ 3.5 multiply
: UM* 0 SWAP 15 FOR DUP UM+ >R >R DUP UM+ R> + R> IF >R OVER UM+ R> THEN NEXT ROT DROP ;
: * UM* DROP ;
: M* 2DUP XOR 0< >R ABS SWAP ABS UM* R> IF DNEGATE THEN ;
: */MOD >R M* R> M/MOD ;
: */ */MOD SWAP DROP ;

\ 3.6 memory aligment
: CELL- -2 + ;
: CELL+ 2 + ;
: CELLS 2 * ;
: ALIGNED DUP 0 2 UM/MOD DROP DUP IF 2 SWAP - THEN + ;
: BL 32 ;
: >CHAR $7F AND DUP 127 BL WITHIN IF DROP 95 THEN ;
: DEPTH SP@ SP0 @ SWAP - 2 / ;
: PICK 1 + CELLS SP@ + @ ;

\ 3.7 memory access
: +! SWAP OVER @ + SWAP ! ;
: 2! SWAP OVER ! CELL+ ! ;
: 2@ DUP CELL+ @ SWAP @ ;
: COUNT DUP 1 + SWAP C@ ;
: HERE CP @ ;
: PAD HERE 80 + ;
: TIB #TIB CELL+ @ ;
: @EXECUTE @ ?DUP IF EXECUTE THEN ;
: MOVE FOR AFT >R DUP @ R@ ! 1 + R> 1 + THEN NEXT 2DROP ;
: CMOVE FOR AFT >R DUP C@ R@ C! 1 + R> 1 + THEN NEXT 2DROP ;
: FILL SWAP FOR SWAP AFT 2DUP C! 1 + THEN NEXT 2DROP ;
: -TRAILING FOR AFT BL OVER R@ + C@ < IF R> 1 + EXIT THEN THEN NEXT 0 ;
: PACK$ ALIGNED DUP >R OVER DUP 0 2 UM/MOD DROP - OVER + 0 SWAP ! 2DUP C! 1 + SWAP CMOVE R> ;


\ 4.1 numeric output
: DIGIT 9 OVER < 7 AND + 48 + ;
: EXTRACT 0 SWAP UM/MOD SWAP DIGIT ;
: <# PAD HLD ! ;
: HOLD HLD @ 1 - DUP HLD ! C! ;
: # BASE @ EXTRACT HOLD ;
: #S BEGIN # DUP WHILE REPEAT ;
: SIGN 0< IF 45 HOLD THEN ;
: #> DROP HLD @ PAD OVER - ;
: STR DUP >R ABS <# #S R> SIGN #> ;
: HEX 16 BASE ! ;
: DECIMAL 10 BASE ! ;

\ 4.2 NUMBER OUTPUT
: .R >R STR R> OVER - SPACES TYPE ;
: U.R >R <# #S #> R> OVER - SPACES TYPE ;
: U. <# #S #> SPACE TYPE ;
: . BASE @ 10 XOR IF U. EXIT THEN STR SPACES TYPE ;
:.? @ . ;

\ 4.3 NUMERIC IMPUT
: DIGIT? R> 48 - 9 OVER < IF 7 - DUP 10 < OR THEN DUP R> U< ;
: NUMBER? BASE @ >R 0 OVER COUNT OVER C@ 36 = IF HEX SWAP 1 + SWAP 1 - THEN OVER C@ 36 - IF HEX SWAP 1 + SWAP 1 - THEN OVER C@ 45 = >R SWAP R@ - SWAP R@ + ?DUP IF 1 - FOR DUP >R C@ BASE @ DIGIT? WHILE SWAP BASE @ * + R> 1 + NEXT DROP R@ IF NEGATE THEN SWAP ELSE R> R> 2DROP 2DROP 0 THEN DUP THEN R> 2DROP R> BASE ! ;

\ 4.4 basic I/O
: ?KEY '?KEY @EXECUTE ;
: KEY BEGIN ?KEY UNTIL ;
: EMIT 'EMIT @EXECUTE ;
: NUF? ?KEY DUP IF 2DROP KEY 13 = THEN ; 
: PACE 11 EMIT ;
: SPACE 32 EMIT ;
: CHARS SWAP 0 MAX FOR AFT DUP EMIT THEN NEXT DROP ;
: SPACES 32 CHARS ;
: TYPE FOR AFT DUP C@ EMIT 1 + THEN NEXT DROP ;
: CR 13 EMIT 10 EMIT ;
: DO$ R> R@ R> COUNT + ALIGNED R> SWAP >R ;
: $"| DO$ ;
: ."| DO$ COUNT TYPE ; COMPILE-ONLY

\ 4.5 parsing
: PARSE$ TMP ! OVER >R DUP IF 1 - TMP @ BL = IF FOR BL OVER C@ - 0< NOT WHILE 1 + NEXT R> DROP 0 DUP EXIT THEN R> THEN OVER SWAP FOR TMP @ OVER C@ - TMP @ BL = IF 0< THEN WHILE 1 + NEXT DUP R> ELSE R> DROP DUP 1 + >R THEN OVER - R> R> - EXIT THEN OVER R> - ;
: PARSE >R TIB >IN @ + #TIB @ >IN @ - R> PARSE$ >IN +! ;
: .( 41 PARSE TYPE ; IMMEDIATE
: ( 41 PARSE 2DROP ; IMMEDIATE
: \ #TIB @ >IN ! ; IMMEDIATE
: CHAR BL PARSE DROP C@ ;
: TOKEN BL PARSE 31 MIN NP @ OVER - CELL- PACK$ ;
: WORD PARSE HERE PACK$ ;

\ 4.6 DICTIONARY SEARCH
: NAME> CELL- CELL- @ ;
: SAME? FOR AFT OVER R@ CELLS + @ OVER R@ CELLS + @ - ?DUP IF R> DROP EXIT THEN THEN NEXT 0 ;
: FIND SWAP DUP C@ 2 / TMP ! DUP @ >R CELL+ SWAP BEGIN @ DUP IF DUP @ [ =MASK ] LITERAL AND R@ XOR IF CELL+ -1 ELSE CELL+ TMP @ SAME? THEN ELSE R> DROP EXIT THEN WHILE CELL- CELL- REPEAT R> DROP SWAP DROP CELL- DUP NAME> SWAP ;
: NAME? CONTEXT DUP 2@ XOR IF CELL- THEN >R BEGIN R> CELL+ DUP >R @ ?DUP WHILE FIND ?DUP UNTIL R> DROP EXIT THEN R> DROP 0 ;

\ 4.7 terminal
: ^H >R OVER R> SWAP OVER XOR IF 8 'ECHO @EXECUTE 32 'ECHO @EXECUTE 8 'ECHO @EXECUTE THEN ;
: TAP DUP 'ECHO @EXECUTE OVER C! 1 + ;
: KTAP DUP 13 XOR IF 8 XOR IF BL TAP ELSE ^H THEN EXIT THEN DROP SWAP DROP DUP ;
: ACCEPT OVER + OVER BEGIN 2DUP XOR WHILE KEY DUP BL - 95 U< IF TAP ELSE 'TAP @EXECUTE THEN REPEAT DROP OVER - ;
: EXPECT 'EXPECT @EXECUTE SPAN ! DROP ;
: QUERY TIB 80 'EXPECT @EXECUTE #TIB ! DROP 0 >IN ! ;

\ 4.8 error handle
: NULL$ 0 , $," coyote " ;

: CATCH SP@ >R HANDLER @ >R RP@ HANDLER ! EXECUTE R> HANDLER ! R> DROP 0 ;
: THROW HANDLER @ RP! R> HANDLER ! R> SWAP R> SP! DROP R> ;
: ABORT NULL$ THROW ;
: ABORT" IF DO$ THROW THEN DO$ DROP ;
: ?STACK DEPTH 0< IF $" underflow " THROW THEN ;

: [INTERPRET] BEGIN QUERY [ ' EVAL ] LITERAL CATCH ?DUP UNTIL ;

\ 4.9 text interpreter
: $INTERPRET NAME? ?DUP IF @ $40 AND ABORT" compile only " EXECUTE EXIT THEN 'NUMBER @EXECUTE IF EXIT THEN THROW ;
: [ DOLIT $INTERPRET 'EVAL ! ; IMMEDIATE
: ] DOLIT $COMPILE 'EVAL ! ;
: .OK DOLIT $INTERPRET 'EVAL @ = IF ." ok " THEN CR ;
: ?STACK DEPTH 0< ABORT" underflow " ;
: EVAL BEGIN TOKEN DUP C@ WHILE 'EVAL @EXECUTE ?STACK REPEAT DROP 'PROMPT @EXECUTE ;

\ 4.10 Shell
: PRESET SP0 @ SP! TIB #TIB CELL+ ! ;
: XIO 'EXPECT 'TAP 'ECHO 'PROMPT DOLIT ACCEPT 'EXPECT 2! 'ECHO 2! ; COMPILE-ONLY
: FILE DOLIT PACE DOLIT DROP DOLIT KTAP XIO ;
: HAND DOLIT .OK DOLIT EMIT [ KTAP XIO ;

: I/O ' ?RX , ' TX! , ;

: CONSOLE I/O 2@ '?KEY 2! HAND ;
: QUIT RP0 @ RP! BEGIN [COMPILE] [ BEGIN QUERY DOLIT EVAL CATCH ?DUP UNTIL 'PROMPT @ SWAP CONSOLE NULL$ OVER XOR IF  CR #TIB 2@ TYPE CR >IN @ 94 CHARS CR COUNT TYPE ." ? " THEN DOLIT .OK XOR IF $1B EMIT THEN PRESET AGAIN ;

\ 5.1 interpreter and compiler
: [ [ ' $INTERPRET ] LITERAL 'EVAL ! ; IMMEDIATE
: ] [ ' $COMPILE ] LITERAL 'EVAL ! ;

\ 5.2 primitive compiler words
: ' TOKEN NAME? IF EXIT THEN THROW ;
: , HERE DUP CELL+ CP ! ! ;
: ALLOT CP +! ;
: [COMPILE] R> DUP @ , CELL+ R> ;
: COMPILE ' , ; IMMEDIATE
: LITERAL COMPILE DOLIT , ; IMMEDIATE
: $," 34 WORD COUNT ALIGNED CP ! ;
: RECURSE LAST @ NAME> , ; IMMEDIATE

\ 5.3 strutures
\ _IF_THEN
\ _IF_ELSE_THEN
\ _FOR_NEXT
\ _FOR_AFT_THEN_NEXT
\ _BEGIN_AGAIN
\ _BEGIN_UNTIL
\ _BEGIN_WHILE_REPEAT
: <MARK HERE ;
: <RESOLVE , ;
: >MARK HERE 0 , ;
: >RESOLVE <MARK SWAP ! ;
: FOR COMPILE >R <MARK ; IMMEDIATE
: BEGIN <MARK ; IMMEDIATE
: NEXT COMPILE NEXT <RESOLVE ; IMMEDIATE
: UNTIL COMPILE ?BRANCH <RESOLVE ; IMMEDIATE
: AGAIN COMPILE BRANCH <RESOLVE ; IMMEDIATE
: IF COMPILE ?BRANCH >MARK ; IMMEDIATE
: AHEAD COMPILE BRANCH >MARK ; IMMEDIATE
: REPEAT [COMPILE] AGAIN >RESOLVE ; IMMEDIATE
: THEN >RESOLVE ; IMMEDIATE
: AFT DROP [COMPILE] AHEAD [COMPILE] BEGIN SWAP ; IMMEDIATE
: ELSE [COMPILE] AHEAD SWAP [COMPILE] THEN ; IMMEDIATE
: WHEN [COMPILE] IF OVER ; IMMEDIATE
: WHILE [COMPILE] IF SWAP ; IMMEDIATE
: ABORT" COMPILE ABORT" $," ; IMMEDIATE
: $" COMPILE $"| $," ; IMMEDIATE
: ." COMPILE ."| $," ; IMMEDIATE

\ 5.4 compiler
: ?UNIQUE DUP NAME? IF ." redefined " OVER COUNT TYPE THEN DROP ;
: $,N DUP C@ IF ?UNIQUE DUP LAST ! HERE ALIGNED SWAP CELL- CURRENT @ @ OVER ! CELL- DUP NP ! ! EXIT THEN $" name " THROW ;
: $COMPILE NAME? ?DUP IF @ $80 AND IF EXECUTE ELSE , THEN EXIT THEN 'NUMBER @EXECUTE IF [COMPILE] LITERAL EXIT THEN THROW ;
: OVERT LAST @ CURRENT @ ! ;
: \; COMPILE EXIT [COMPILE] [ OVERT ; IMMEDIATE
: CALL, $e890 , HERE CELL+ - , ;
: \: TOKEN $,N DOLIT DOLIST CALL, ] ;
: IMMEDIATE $80 LAST @ @ OR LAST @ ! ;

\ 5.5 defining words
: USER TOKEN $,N OVERT DOLIT DOLIST COMPILE DOUSER , ;
: CREATE TOKEN $,N DOLIT DOLIST COMPILE DOVAR ;
: VARIABLE CREATE 0 , ;

\ 6.1 utilities
: _TYPE FOR AFT DUP C@ >CHAR EMIT 1 + THEN NEXT DROP ;
: DM+ OVER 4 U.R SPACE FOR AFT DUP C@ 3 U.R 1 + THEN NEXT ;
: DUMP BASE @ >R HEX 16 / FOR CR 16 2DUP DM+ ROT ROT 2 SPACES _TYPE NUF? NOT WHILE NEXT ELSE R> DROP THEN DROP R> BASE ! ;

\ 6.2 stack tools
: .S CR DEPTH FOR AFT R@ PICK . THEN NEXT ." <sp " ;
: .BASE BASE @ DECIMAL DUP . BASE ! ;
: .FREE CP 2@ - U. ;
: !CSP SP@ CSP ! ;
: ?CSP SP@ CSP @ XOR ABORT" stack depth " ;

\ 6.3 dictionary dump
: >NAME CURRENT BEGIN CELL+ @ ?DUP WHILE 2DUP BEGIN @ DUP WHILE 2DUP NAME> XOR WHILE CELL- REPEAT THEN SWAP DROP ?DUP UNTIL SWAP DROP SWAP DROP EXIT THEN DROP 0 ;
: .ID ?DUP IF COUNT $01D AND _TYPE EXIT THEN ." {noName} " ;
: SEE ' CR CELL+ BEGIN CELL+ DUP @ DUP IF >NAME THEN ?DUP IF SPACE .ID ELSE DUP @ U. THEN NUF? UNTIL DROP ;
: WORDS CR CONTEXT @ BEGIN @ ?DUP WHILE DUP SPACE .ID CELL- NUF? UNTIL DROP THEN ;

\ 6.4 startup
: VER $0101 ;
: HI !IO BASE @ HEX CR ." eForth v " VER <# # # 46 HOLD # #> TYPE CR ;
: EMPTY FORTH CONTEXT @ DUP CURRENT 2! 6 CP 3 MOVE OVERT ;

\ CREATE 'BOOT ' HI ,

: 'BOOT ' HI , ;

: COLD BEGIN U0 UP 74 CMOVE PRESET 'BOOT @EXECUTE FORTH CONTEXT @ DUP CURRENT 2! OVERT QUIT AGAIN ;

\ uzero: dup: spp: rpp: wrx: txsto: accep: ktap: txsto: dotok: basee: tmp: span: >in: #tib: tib: csp: inter: numbq:

\ $NEXT
\ DOLIST
\ CODE 
\ EXIT



